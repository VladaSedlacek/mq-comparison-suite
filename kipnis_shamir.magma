//Version with zero constants!

clear ;

q:=17; // field size
parameters:=[5,5]; // Rainbow parameters (v_1, o_1, ..., o_u)
u:= #parameters -1;

v:=[];
o:=[];

v[1]:=parameters[1];
for i:=1 to u do
    o[i]:=parameters[i+1];
    v[i+1]:=v[i]+o[i];
end for;

n:=v[u+1];
m:=n-v[1];
GF<w>:=GaloisField(q);
Vn:=VectorSpace(GF,n);
Vm:=VectorSpace(GF,m);

P<[x]>:=PolynomialRing(GF,n);
Pol<[y]>:=PolynomialRing(P,n);


// key generation
// affine map T -----------------------------------------------------------------------------
repeat
    MT:=RandomMatrix(GF,n,n);
until IsInvertible(MT) eq true;
cT:= Random(Vn);

T:=[];
for i:=1 to n do
    T[i]:=P!0;
    for j:=1 to n do
        T[i]:=T[i]+MT[i][j]*x[j];
    end for;
    //T[i]:=T[i]+cT[i];
end for;

// central map Q ---------------------------------------------------------------------------
Qc:=[]; Q:=[];

for greatloop:=1 to u do

    for loop:=v[greatloop]-v[1]+1 to v[greatloop+1]-v[1] do // greatloop-th Layer --------------------------------
        Q[loop]:=Pol!0;

        for i:=1 to v[greatloop] do
            for j:=1 to v[greatloop+1] do
                Q[loop]:=Q[loop] + Random(GF)*Pol.i*Pol.j;
            end for;
        end for;

//      for i:=1 to v[greatloop+1] do
//          Q[loop]:= Q[loop] + Random(GF)*Pol.i;
//      end for;
//
//      Q[loop]:=Q[loop]+Random(GF);

    end for;
end for; 

// affine map S ---------------------------------------------------------------------------------------

repeat
    MSF:=RandomMatrix(GF,m,m);
until IsInvertible(MSF) eq true;
cS:=Matrix(Pol,m,1,ChangeUniverse(Eltseq(Random(Vm)),Pol));
MS:=Matrix(Pol,m,m,ChangeUniverse(Eltseq(MSF),Pol));

// public key Pk ----------------------------------------------------------------------------
QT:=ZeroMatrix(Pol,m,1);
for i:=1 to m do
    QT[i][1]:=Evaluate(Q[i],y[1], T[1]);
    for j:=2 to n do
        QT[i][1]:=Evaluate(QT[i][1],y[j], T[j]);
    end for;
end for;

//Pk:=MS*QT+cS;
Pk:=MS*QT;

D:=[];
for i:=1 to m do
    D[i]:=MonomialCoefficient(Pk[i][1],1);
end for;
Pk := D;

Pk_polar := [];

for l:=1 to m do
    M := ZeroMatrix(GF, n);
    for i:=1 to n do
        for j:=i to n do
            M[i][j] := MonomialCoefficient(Pk[l], x[i]*x[j]);
        end for;
    end for;
Pk_polar[l] := M + Transpose(M);
end for;

success := 0;
for i in [1..m] do
    for j in [i+1..m] do
        Mi := Pk_polar[i];
        Mj := Pk_polar[j];
        if IsInvertible(Mi) and IsInvertible(Mj) then
            Mij := Pk_polar[i] * Pk_polar[j]^(-1);    
            poly<z> := Sqrt(CharacteristicPolynomial(Mij));
            U := Evaluate(poly, Mij);
            if Rank(U) eq m then
                O := Nullspace(U);
                success := 1;
                //print i,j, Factorization(poly), O;
                break j;
                break i;
            end if;
        end if;
    end for;
end for;

if success eq 0 then
    exit;
end if;

print "O:", O;
print "Pk_polar:", Pk_polar;
//print Pk;
//print "QT:", QT;

for j in [1..m] do 
    for o1 in Basis(O) do
        for o2 in Basis(O) do
            if not DotProduct(o1 * Pk_polar[j], o2) eq 0 then
                print "Nonzero product!", DotProduct(o1 * Pk_polar[j], o2);
            end if;
        end for;
    end for;
end for;

 
for j in [1..m] do
    Ev := Pk[j];
    for o in Basis(O) do
        for i in [1..n] do
            Ev := Evaluate(Ev, x[i], o[i]);
        end for;
    if not Ev eq 0 then
            print "Nonzero evaluation!", Ev;
        end if;
    end for;
end for;